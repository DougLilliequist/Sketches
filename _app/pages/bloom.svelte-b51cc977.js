import{M as e,_ as r,P as t,$ as i,T as s,a0 as n,a1 as a,R as l,I as o,O as h,V as u,J as c,S as g,i as v,s as m,e as p,c as f,a as d,d as x,b as _,K as w,f as S,F as z,L as y,N as P,G as b,A as B,Q as T,U as C,W as M}from"../chunks/vendor-5daa0285.js";class D extends e{constructor(e){super(e),this.gl=e,this.geometry=new r(this.gl,{radius:.8,widthSegments:64,heightSegments:32}),this.program=new t(this.gl,{vertex:"precision highp float;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    vNormal = normal;\r\n\r\n}\r\n",fragment:"precision highp float;\r\n\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n\r\n    gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1.0);\r\n//    gl_FragColor = vec4(vec3(1.0, 0.5, 0.12), 1.0);\r\n\r\n}"})}}class R{constructor(e){this.gl=e,this.createRenderTarget(),this.initProgram()}createRenderTarget(){return new i(this.gl)}initProgram(){const r={tMap:{value:new s(this.gl)},_Resolution:{value:new n(this.gl.canvas.width,this.gl.canvas.height)}};this.colorPass=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:"precision highp float;\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n\r\n    vUv = uv;\r\n\r\n}",fragment:"precision highp float;\r\n// Default uniform for previous pass is 'tMap'.\r\n// Can change this using the 'textureUniform' property\r\n// when adding a pass.\r\nuniform sampler2D tMap;\r\nuniform vec2 _Resolution;\r\nvarying vec2 vUv;\r\n\r\nfloat luma(vec4 color) {\r\n    return dot(color.xyz, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 resolution) {\r\n    vec2 pixel = vec2(1) / resolution;\r\n    vec3 l = vec3(0.299, 0.587, 0.114);\r\n    float lNW = dot(texture2D(tex, uv + vec2(-1, -1) * pixel).rgb, l);\r\n    float lNE = dot(texture2D(tex, uv + vec2( 1, -1) * pixel).rgb, l);\r\n    float lSW = dot(texture2D(tex, uv + vec2(-1,  1) * pixel).rgb, l);\r\n    float lSE = dot(texture2D(tex, uv + vec2( 1,  1) * pixel).rgb, l);\r\n    float lM  = dot(texture2D(tex, uv).rgb, l);\r\n    float lMin = min(lM, min(min(lNW, lNE), min(lSW, lSE)));\r\n    float lMax = max(lM, max(max(lNW, lNE), max(lSW, lSE)));\r\n\r\n    vec2 dir = vec2(\r\n    -((lNW + lNE) - (lSW + lSE)),\r\n    ((lNW + lSW) - (lNE + lSE))\r\n    );\r\n\r\n    float dirReduce = max((lNW + lNE + lSW + lSE) * 0.03125, 0.0078125);\r\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\r\n    dir = min(vec2(8, 8), max(vec2(-8, -8), dir * rcpDirMin)) * pixel;\r\n\r\n\r\n    //the inclusion of alpha is based on THREE's take on FXAA\r\n    //https://github.com/assiprinz/threejs-unreal-post/blob/master/js/shaders/FXAAShader.js\r\n    vec4 rgbA = 0.5 * (\r\n    texture2D(tex, uv + dir * (1.0 / 3.0 - 0.5)) +\r\n    texture2D(tex, uv + dir * (2.0 / 3.0 - 0.5)));\r\n    vec4 rgbB = rgbA * 0.5 + 0.25 * (\r\n    texture2D(tex, uv + dir * -0.5) +\r\n    texture2D(tex, uv + dir * 0.5));\r\n    float lB = dot(rgbB, vec4(l, 0.0));\r\n    return mix(\r\n    vec4(rgbB),\r\n    vec4(rgbA),\r\n    max(sign(lB - lMin), 0.0) * max(sign(lB - lMax), 0.0)\r\n    );\r\n}\r\nvoid main() {\r\n    vec4 aa = fxaa(tMap, vUv, _Resolution);\r\n    gl_FragColor = aa;\r\n}",depthWrite:!1,depthTest:!1,cullFace:null})}),this.colorPassTarget=new i(this.gl)}render({pass:e}){this.colorPass.program.uniforms.tMap.value=e,this.gl.renderer.render({scene:this.colorPass,target:this.colorPassTarget,clear:!1})}onResize({width:e,height:r}){this.colorPassTarget=this.createRenderTarget(),this.colorPass.program.uniforms._Resolution.value.set(this.gl.canvas.width,this.gl.canvas.height)}get Output(){return this.colorPassTarget.texture}get EmissiveMask(){return this.emissivePassTarget.texture}}var U="precision highp float;\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n    vUv = uv;\r\n}";class F{constructor(e,{width:r,height:t}){this.gl=e,this.resolutionScale=.5,this.setSize({width:r,height:t}),this.initBlurPasses()}initBlurPasses(){this.createBlurBuffers();const r={_Image:{value:new s(this.gl)},_StepSize:{value:1},_Time:{value:0},_Resolution:{value:new n(Math.floor(this.width*this.resolutionScale),Math.floor(this.height*this.resolutionScale))},_Seed:{value:0}};this.downsamplePass=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{vertex:U,fragment:"precision highp float;\r\n\r\nuniform sampler2D _Image;\r\nuniform vec2 _Resolution;\r\n\r\nuniform float _StepSize;\r\nuniform float _Time;\r\n\r\nuniform float _Seed;\r\n\r\nvarying vec2 vUv;\r\n\r\n\r\nfloat hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nvec3 lin2srgb(vec3 c) {\r\n    return sqrt(c);\r\n}\r\n\r\nvec3 srgb2lin(vec3 c) {\r\n    return c * c;\r\n}\r\n\r\nvoid main() {\r\n    \r\n    vec2 texelSize = 1.0 / _Resolution;\r\n\r\n    vec3 col = texture2D(_Image, vUv).xyz * 4.0;\r\n    col += texture2D(_Image, vUv + texelSize * _StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(texelSize.x, -texelSize.y) * _StepSize).xyz;\r\n    col += texture2D(_Image, vUv - texelSize * _StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(-texelSize.x, +texelSize.y) * _StepSize).xyz;\r\n    col /= 8.0;\r\n\r\n    vec3 hash1 = hash32(gl_FragCoord.xy+fract(_Time)*1651.0 + _Seed);\r\n    vec3 hash2 = hash32(gl_FragCoord.yx+fract(_Time+0.3123)*1213.0 + _Seed);\r\n    vec3 dither = ((hash1) + (hash2-1.0)) / 255.0;\r\n\r\n    // Output to screen\r\n    gl_FragColor = vec4(col+dither,1.0);\r\n\r\n}",uniforms:r,transparent:!1,depthTest:!1,depthWrite:!1})}),this.upsamplePass=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{vertex:U,fragment:"precision highp float;\r\n\r\nuniform sampler2D _Image;\r\nuniform vec2 _Resolution;\r\n\r\nuniform float _StepSize;\r\nuniform float _Time;\r\n\r\nuniform float _Seed;\r\n\r\nvarying vec2 vUv;\r\n\r\n\r\nfloat hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nvoid main() {\r\n    \r\n    vec2 texelSize = 1.0 / _Resolution;\r\n\r\n    vec2 texelSizeHalf = texelSize * 0.5;\r\n\r\n    vec3 col = texture2D(_Image, vUv + vec2(-texelSizeHalf.x * 2.0, 0.0)*_StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(-texelSizeHalf.x, texelSizeHalf.y)*_StepSize).xyz * 2.0;\r\n    col += texture2D(_Image, vUv + vec2(0.0, texelSizeHalf.y * 2.0)*_StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(texelSizeHalf.x, texelSizeHalf.y)*_StepSize).xyz * 2.0;\r\n    col += texture2D(_Image, vUv + vec2(texelSizeHalf.x * 2.0, 0.0)*_StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(texelSizeHalf.x, -texelSizeHalf.y)*_StepSize).xyz * 2.0;\r\n    col += texture2D(_Image, vUv + vec2(0.0, -texelSizeHalf.y * 2.0)*_StepSize).xyz;\r\n    col += texture2D(_Image, vUv + vec2(-texelSizeHalf.x, -texelSizeHalf.y)*_StepSize).xyz * 2.0;\r\n\r\n    col /= 12.0;\r\n\r\n    vec3 hash1 = hash32(gl_FragCoord.xy+fract(_Time)*1351.0 + _Seed);\r\n    vec3 hash2 = hash32(gl_FragCoord.yx+fract(_Time+0.3123)*1713.0 + _Seed);\r\n    vec3 dither = ((hash1) + (hash2-1.0)) / 255.0;\r\n\r\n    // Output to screen\r\n    gl_FragColor = vec4(col+dither,1.0);\r\n\r\n}",uniforms:r,transparent:!1,depthTest:!1,depthWrite:!1})})}render({pass:e,time:r}){for(let t=0;t<this.blurBuffers.length-1;t++)0===t?(this.downsamplePass.program.uniforms._Image.value=e.texture,this.downsamplePass.program.uniforms._Resolution.value.set(e.width,e.height)):(this.downsamplePass.program.uniforms._Image.value=this.blurBuffers[t].buffer.texture,this.downsamplePass.program.uniforms._Resolution.value.copy(this.blurBuffers[t].resolution)),this.downsamplePass.program.uniforms._Seed.value=100*t*Math.random(),this.downsamplePass.program.uniforms._Time.value=r,this.gl.renderer.render({scene:this.downsamplePass,target:this.blurBuffers[t+1].buffer,clear:!1});for(let t=this.blurBuffers.length-1;t>0;t--)this.upsamplePass.program.uniforms._Image.value=this.blurBuffers[t].buffer.texture,this.upsamplePass.program.uniforms._Resolution.value.copy(this.blurBuffers[t].resolution),this.upsamplePass.program.uniforms._Time.value=r,this.upsamplePass.program.uniforms._Seed.value=100*t*Math.random(),this.gl.renderer.render({scene:this.upsamplePass,target:this.blurBuffers[t-1].buffer,clear:!1})}createBlurBuffers(){this.blurBuffers=new Array(4);let e=1;for(let r=0;r<this.blurBuffers.length;r++){const t={width:Math.floor(this.width*this.resolutionScale*e),height:Math.floor(this.height*this.resolutionScale*e),minFilter:this.gl.LINEAR,magFilter:this.gl.LINEAR,format:this.gl.RGB,internalFormat:this.gl.RGB,depth:!1};this.blurBuffers[r]={buffer:new i(this.gl,t),resolution:new n(t.width,t.height)},e*=.5}}onResize({width:e,height:r}){this.setSize({width:e,height:r}),this.createBlurBuffers()}setSize({width:e,height:r}){this.width=null===e?this.gl.canvas.width:e,this.height=null===r?this.gl.canvas.height:r}get Output(){return this.blurBuffers[0].buffer.texture}}var E="precision highp float;\r\n\r\nuniform sampler2D _Pass;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    vec4 col = texture2D(_Pass, vUv);\r\n    gl_FragColor = col;\r\n\r\n}",W="precision highp float;\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n\r\n    vUv = uv;\r\n\r\n}";class N{constructor(e,{width:r,height:t}){this.gl=e,this.resolutionScale=.25,this.setSize({width:r,height:t}),this.initCapturePass(),this.initProgram()}setSize({width:e,height:r}){this.width=null===e?this.gl.canvas.width:e,this.height=null===r?this.gl.canvas.height:r}initCapturePass(){const r={_Pass:{value:new s(this.gl)},_EmissiveMask:{value:new s(this.gl)}};this.captureProgram=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:W,fragment:E,depthTest:!1,depthWrite:!1,cull:null})})}initProgram(){this.createBlurBuffers();const r={_Color:{value:new s(this.gl)},_Resolution:{value:new n(Math.floor(this.width),Math.floor(this.height))},_Time:{value:0},_Seed:{value:0},_StepSize:{value:.5}};this.program=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:W,fragment:"precision highp float;\r\n\r\nuniform sampler2D _Color;\r\nuniform vec2 _Resolution;\r\n\r\nuniform float _StepSize;\r\nuniform float _Time;\r\n\r\nuniform float _Seed;\r\n\r\nvarying vec2 vUv;\r\n\r\n\r\nfloat hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nvoid main() {\r\n    \r\n    vec2 texelSize = 1.0 / _Resolution;\r\n\r\n    vec3 col = texture2D(_Color, vUv + texelSize * _StepSize).xyz;\r\n    col += texture2D(_Color, vUv - texelSize * _StepSize).xyz;\r\n    col += texture2D(_Color, vUv + vec2(texelSize.x, -texelSize.y) * _StepSize).xyz;\r\n    col += texture2D(_Color, vUv + vec2(-texelSize.x, +texelSize.y) * _StepSize).xyz;\r\n    col /= 4.0;\r\n\r\n    vec3 hash1 = hash32(gl_FragCoord.xy+fract(_Time)*1300.0 + _Seed * 150.0);\r\n    vec3 hash2 = hash32(gl_FragCoord.yx+fract(_Time+0.3123)*1300.0 + _Seed * 137.0);\r\n    vec3 dither = ((hash1) + (hash2-1.0)) / 255.0;\r\n\r\n    // Output to screen\r\n    gl_FragColor = vec4(col+dither,1.0);\r\n\r\n}",depthTest:!1,depthWrite:!1,transparent:!1,cullFace:null})})}render({pass:e,time:r}){this.captureProgram.program.uniforms._Pass.value=e.texture,this.gl.renderer.render({scene:this.captureProgram,target:this.blurBuffers[0].buffer,clear:!1});for(let t=0;t<this.blurBuffers.length-1;t++)this.program.program.uniforms._Color.value=this.blurBuffers[t].buffer.texture,this.program.program.uniforms._Resolution.value.copy(this.blurBuffers[t].resolution),this.program.program.uniforms._Time.value=r,this.program.program.uniforms._Seed.value=t+1e3*Math.random(),this.program.program.uniforms._StepSize.value=.5+t,this.gl.renderer.render({scene:this.program,target:this.blurBuffers[t+1].buffer,clear:!1})}createBlurBuffers(){this.blurBuffers=new Array(8);for(let e=0;e<this.blurBuffers.length;e++){const r={width:Math.floor(this.width*this.resolutionScale),height:Math.floor(this.height*this.resolutionScale),minFilter:this.gl.LINEAR,magFilter:this.gl.LINEAR,format:this.gl.RGB,internalFormat:this.gl.RGB,depth:!1};this.blurBuffers[e]={buffer:new i(this.gl,r),resolution:new n(r.width,r.height)}}}onResize({width:e,height:r}){}get Output(){return this.blurBuffers[this.blurBuffers.length-1].buffer.texture}}class I{constructor(e){this.gl=e,this.resolutionScale=.5,this.setSize({width:this.gl.canvas.width,height:this.gl.canvas.height}),this.initCapturePass(),this.initLumaMaskPass(),this.initBlurPasses(),this.initCompositePass()}initCapturePass(){const r={_Pass:{value:new s(this.gl)}};this.captureProgram=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:U,fragment:E,depthTest:!1,depthWrite:!1,cull:null})}),this.captureTarget=this.createCaptureTarget()}createCaptureTarget(){return new i(this.gl,{width:Math.floor(this.width*this.resolutionScale),height:Math.floor(this.height*this.resolutionScale)})}initLumaMaskPass(){const r={_ColorPass:{value:this.captureTarget.texture},_BrightnessThreshold:{value:.2},_SmoothWidth:{value:.2}};this.lumaMaskProgram=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:U,fragment:"precision highp float;\r\n\r\nuniform sampler2D _ColorPass;\r\n\r\nuniform float _BrightnessThreshold;\r\nuniform float _SmoothWidth;\r\nuniform float _Intensity;\r\n\r\nvarying vec2 vUv;\r\n\r\n#define CLEARCOL vec3(0.0, 0.0, 0.0)\r\n\r\nfloat luma(vec3 color) {\r\n    return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat luma(vec4 color) {\r\n    return dot(color.xyz, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\n//remix of following implementation:\r\n//https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/LuminosityHighPassShader.js\r\nvoid main() {\r\n\r\n    vec4 col = texture2D(_ColorPass, vUv).xyzw;\r\n    col.xyz = mix(vec3(0.0), col.xyz, col.w);\r\n\r\n//    float lumaLevel = luma(col);\r\n//    float alpha = smoothstep( _BrightnessThreshold, _BrightnessThreshold + _SmoothWidth, lumaLevel );\r\n//    vec3 mask = mix(CLEARCOL, col, alpha);\r\n\r\n    gl_FragColor = vec4(col.xyz, 1.0);\r\n\r\n}",depthTest:!1,depthWrite:!1,cull:null})}),this.lumaMaskPassTarget=new i(this.gl,{width:Math.floor(this.width*this.resolutionScale),height:Math.floor(this.height*this.resolutionScale)})}initBlurPasses(){this.wideBlur=new N(this.gl,{width:this.gl.canvas.width,height:this.gl.canvas.height}),this.blurPass=new F(this.gl,{width:this.gl.canvas.width,height:this.gl.canvas.height})}initCompositePass(){const r={_NarrowBlur:{value:this.blurPass.Output},_WideBlur:{value:this.wideBlur.Output},_Emissive:{value:this.lumaMaskPassTarget.texture}};this.bloomCompositeProgram=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:U,fragment:"precision highp float;\r\n\r\nuniform sampler2D _NarrowBlur;\r\nuniform sampler2D _WideBlur;\r\nuniform sampler2D _Emissive;\r\n\r\nvarying vec2 vUv;\r\n\r\n#define NARROW_GLOW_INTENSITY 1.0\r\n\r\nvec3 screenBlend(vec3 a, vec3 b) {\r\n\r\n    return 1.0 - ((1.0 - a) * (1.0 - b));\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 narrowBloom = texture2D(_NarrowBlur, vUv).xyz * 1.0;\r\n    vec3 wideBloom = texture2D(_WideBlur, vUv).xyz;\r\n    vec3 emissive = texture2D(_Emissive, vUv).xyz * 1.0;\r\n\r\n    vec3 finalBloom = wideBloom+narrowBloom;\r\n\r\n    gl_FragColor = vec4(finalBloom, 1.0);\r\n\r\n}",depthTest:!1,depthWrite:!1,transparent:!1,cullFace:null})}),this.bloomTarget=new i(this.gl,{width:Math.floor(this.width*this.resolutionScale),height:Math.floor(this.height*this.resolutionScale)})}render({pass:e,time:r}){this.captureProgram.program.uniforms._Pass.value=e,this.gl.renderer.render({scene:this.captureProgram,target:this.captureTarget,clear:!1}),this.wideBlur.render({pass:this.captureTarget,time:r}),this.lumaMaskProgram.program.uniforms._ColorPass.value=this.captureTarget.texture,this.gl.renderer.render({scene:this.lumaMaskProgram,target:this.lumaMaskPassTarget,clear:!1}),this.blurPass.render({pass:this.lumaMaskPassTarget,time:r}),this.bloomCompositeProgram.program.uniforms._NarrowBlur.value=this.blurPass.Output,this.bloomCompositeProgram.program.uniforms._WideBlur.value=this.wideBlur.Output,this.bloomCompositeProgram.program.uniforms._Emissive.value=this.lumaMaskPassTarget.texture,this.gl.renderer.render({scene:this.bloomCompositeProgram,target:this.bloomTarget,clear:!1})}setSize({width:e,height:r}){this.width=null===e?this.gl.canvas.width:e,this.height=null===r?this.gl.canvas.height:r}onResize({width:e,height:r}){this.captureTarget=this.createCaptureTarget()}get Output(){return this.bloomTarget.texture}}class A extends e{constructor(e){super(e),this.gl=e,this.passes=[],this.createSceneCaptureTarget(),this.initFXAAPass(),this.initBloomPass(),this.initFinalPass()}createSceneCaptureTarget(){const e={minFilter:this.gl.LINEAR,magFilter:this.gl.LINEAR,wrapS:this.gl.CLAMP_TO_EDGE,wrapT:this.gl.CLAMP_TO_EDGE};this.sceneCaptureTarget=new i(this.gl,e)}initFXAAPass(){this.fxaa=new R(this.gl),this.passes.push(this.fxaa)}initBloomPass(){this.bloomPass=new I(this.gl)}initFinalPass(){const r={_FxaaPassOutput:{value:this.fxaa.Output},_BlooomPassOutput:{value:this.bloomPass.Output},_Time:{value:0}};this.finalPass=new e(this.gl,{geometry:new a(this.gl),program:new t(this.gl,{uniforms:r,vertex:"precision highp float;\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n\r\n    vUv = uv;\r\n\r\n}\r\n",fragment:"precision highp float;\r\n\r\nuniform sampler2D _FxaaPassOutput;\r\nuniform sampler2D _BlooomPassOutput;\r\n\r\nuniform float _Time;\r\n\r\nvarying vec2 vUv;\r\n\r\nvec3 hash32(vec2 p)\r\n{\r\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nvec3 screenBlend(vec3 a, vec3 b) {\r\n\r\n    return 1.0 - ((1.0 - a) * (1.0 - b));\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 fxaaPass = texture2D(_FxaaPassOutput, vUv).xyz;\r\n    vec3 bloomPass = texture2D(_BlooomPassOutput, vUv).xyz;\r\n\r\n    vec3 finalCol = screenBlend(fxaaPass, bloomPass);\r\n\r\n    vec3 hash1 = hash32(gl_FragCoord.xy+fract(_Time)*1300.0);\r\n    vec3 hash2 = hash32(gl_FragCoord.yx+fract(_Time+0.3123)*1300.0);\r\n    vec3 dither = ((hash1) + (hash2-1.0)) / 255.0;\r\n\r\n    gl_FragColor = vec4(finalCol + dither, 1.0);\r\n\r\n}",depthTest:!1,depthWrite:!1,transparent:!1,cullFace:null})})}render({scene:e,camera:r,time:t}){r?this.gl.renderer.render({scene:e,camera:r,target:this.sceneCaptureTarget,clear:!0}):this.gl.renderer.render({scene:e,target:this.sceneCaptureTarget,clear:!0}),this.fxaa.render({pass:this.sceneCaptureTarget.texture}),this.bloomPass.render({pass:this.fxaa.Output,time:t}),this.finalPass.program.uniforms._Time.value=t,this.gl.renderer.render({scene:this.finalPass,clear:!1})}onResize({width:e,height:r}){this.createSceneCaptureTarget(),this.fxaa.onResize(),this.blurPass.onResize({width:this.gl.canvas.width,height:this.gl.canvas.height})}}class O{constructor({el:e}){this.init({el:e})}init({el:e}){this.renderer=new l({canvas:e,width:e.clientWidth,height:e.clientHeight,antialias:!1,dpr:1}),this.gl=this.renderer.gl;this.gl.clearColor(.8,.8,.9,0);const{clientWidth:r,clientHeight:t}=this.gl.canvas;this.wk=1/r,this.hK=1/t,this.camera=new o(this.gl,{aspect:r/t}),this.camera.position.x=0,this.camera.position.y=0,this.camera.position.z=10,this.controls=new h(this.camera,{target:new u(0,0,0)}),this.renderToScreen=!1,this.scene=new c,this.sphere=new D(this.gl),this.sphere.setParent(this.scene),this.initPostPass()}initPostPass(){this.post=new A(this.gl)}render({scene:e,camera:r=null,target:t=null,clear:i,time:s=0}){this.renderToScreen?this.renderer.render({scene:e,camera:r,clear:i}):this.post.render({scene:e,camera:r,time:s})}update({time:e,deltaTime:r}){this.controls.update(),this.render({scene:this.scene,camera:this.camera,clear:!0,time:.001*e})}onResize(e,r){if(e&&r){this.renderer.setSize(e,r);const{clientWidth:t,clientHeight:i}=this.gl.canvas;this.wk=1/t,this.hK=1/i,this.camera.perspective({aspect:t/i})}}}const{window:H}=T;function L(e){let r,t,i,s,n;return{c(){r=p("main"),t=p("canvas"),this.h()},l(e){r=f(e,"MAIN",{class:!0});var i=d(r);t=f(i,"CANVAS",{class:!0}),d(t).forEach(x),i.forEach(x),this.h()},h(){_(t,"class","webgl-canvas svelte-q6ubty"),_(r,"class","sketch svelte-q6ubty"),w((()=>e[7].call(r)))},m(a,l){S(a,r,l),z(r,t),e[5](t),e[6](r),i=y(r,e[7].bind(r)),s||(n=P(H,"resize",e[4]),s=!0)},p:b,i:b,o:b,d(t){t&&x(r),e[5](null),e[6](null),i(),s=!1,n()}}}function k(e,r,t){let i,s,n,a=2,l=2,o=0,h=0,u=0;B((async()=>{await C(),n=new O({el:s}),c()}));const c=()=>{window.requestAnimationFrame((()=>c())),o=performance.now(),h=.001*(o-u),u=o,n.update({time:o,deltaTime:h})};return[i,s,a,l,()=>{n.onresize({width:a,height:l})},function(e){M[e?"unshift":"push"]((()=>{s=e,t(1,s)}))},function(e){M[e?"unshift":"push"]((()=>{i=e,t(0,i)}))},function(){a=this.clientWidth,l=this.clientHeight,t(2,a),t(3,l)}]}export default class extends g{constructor(e){super(),v(this,e,k,L,m,{})}}
