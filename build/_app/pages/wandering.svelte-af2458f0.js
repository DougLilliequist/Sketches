var e=Object.defineProperty,t=(t,n,i)=>(((t,n,i)=>{n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i})(t,"symbol"!=typeof n?n+"":n,i),i);import{J as n,V as i,P as s,R as a,I as r,O as o,Z as l,S as c,i as h,s as d,e as m,c as f,a as u,d as v,b as g,K as p,f as x,F as M,L as w,N as b,G as y,A as P,Q as k,U as T,W as I}from"../chunks/vendor-5daa0285.js";class N extends n{constructor(e,{gltf:t}){super(e),this.gl=e,this.gltf=t,this.mesh,this.skin,this.loadGLTF(),this.currentPos=new i(0,0,0),this.prevPos=new i(0,0,0),this.velocity=new i(0,0,0),this.acc=new i(0,0,0),this.directionOffset=new i(0,0,0),this.directionOffsetRadius=2,this.directionStep=2,this.PI2=2*Math.PI,this.updateDirection=!1,this.randomAngle=Math.random()*this.PI2}loadGLTF(){this.children.forEach((e=>e.setParent(null)));(this.gltf.scene||this.gltf.scenes[0]).forEach((e=>{e.setParent(this),e.traverse((e=>{e.program&&(e.program=this.createProgram(e))}))})),this.updateMatrixWorld();const e=new i(1/0),t=new i(-1/0),n=new i,s=new i,a=new i,r=new i,o=new i,l=new i;console.log(this.gltf.meshes),this.gltf.meshes.forEach((n=>{n.primitives.forEach((n=>{if(!n.parent)return;n.geometry.bounds||n.geometry.computeBoundingSphere(),o.copy(n.geometry.bounds.center).applyMatrix4(n.worldMatrix),n.worldMatrix.getScaling(l);const i=Math.max(Math.max(l[0],l[1]),l[2]),s=n.geometry.bounds.radius*i;a.set(-s).add(o),r.set(+s).add(o);for(let o=0;o<3;o++)e[o]=Math.min(e[o],a[o]),t[o]=Math.max(t[o],r[o]);this.mesh=n}))})),s.sub(t,e),Math.max(Math.max(s[0],s[1]),s[2]),n.add(e,t).divide(2)}createProgram(e){let t=`\n        ${e.geometry.attributes.uv?"#define UV":""}\n        ${e.geometry.attributes.normal?"#define NORMAL":""}\n        ${e.geometry.isInstanced?"#define INSTANCED":""}\n        ${e.boneTexture?"#define SKINNING":""}\n        ${"MASK"===this.gltf.alphaMode?"#define ALPHA_MASK":""}\n        ${this.gltf.baseColorTexture?"#define COLOR_MAP":""}\n        ${this.gltf.normalTexture?"#define NORMAL_MAP":""}\n        ${this.gltf.metallicRoughnessTexture?"#define RM_MAP":""}\n        ${this.gltf.occlusionTexture?"#define OCC_MAP":""}\n        ${this.gltf.emissiveTexture?"#define EMISSIVE_MAP":""}\n    `,n=t+"\n                    precision highp float;\n                    attribute vec3 position;\n                    #ifdef UV\n                        attribute vec2 uv;\n                    #else\n                        const vec2 uv = vec2(0);\n                    #endif\n                    #ifdef NORMAL\n                        attribute vec3 normal;\n                    #else\n                        const vec3 normal = vec3(0);\n                    #endif\n                    #ifdef INSTANCED\n                        attribute mat4 instanceMatrix;\n                    #endif\n                    #ifdef SKINNING\n                        attribute vec4 skinIndex;\n                        attribute vec4 skinWeight;\n                    #endif\n                    uniform mat4 modelViewMatrix;\n                    uniform mat4 projectionMatrix;\n                    uniform mat4 modelMatrix;\n                    uniform mat3 normalMatrix;\n\n                    uniform vec3 _Forward;\n                    uniform vec3 _WorldPosOffset;\n\n                    vec3 rotateToTarget(vec3 forward, vec3 p) {\n\n                        vec3 up = vec3(0.0, 1.0, 0.0);\n                        vec3 right = normalize(cross(forward, up));\n\n                        return (right * p.x) + (up * p.y) + (forward * p.z);\n\n                    }\n\n                    #ifdef SKINNING\n                        uniform sampler2D boneTexture;\n                        uniform int boneTextureSize;\n                    #endif\n                    varying vec2 vUv;\n                    varying vec3 vNormal;\n                    varying vec3 vMPos;\n                    varying vec4 vMVPos;\n\n                    #ifdef SKINNING\n                        mat4 getBoneMatrix(const in float i) {\n                            float j = i * 4.0;\n                            float x = mod(j, float(boneTextureSize));\n                            float y = floor(j / float(boneTextureSize));\n                            float dx = 1.0 / float(boneTextureSize);\n                            float dy = 1.0 / float(boneTextureSize);\n                            y = dy * (y + 0.5);\n                            vec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));\n                            vec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));\n                            vec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));\n                            vec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));\n                            return mat4(v1, v2, v3, v4);\n                        }\n                        void skin(inout vec4 pos, inout vec3 nml) {\n                            mat4 boneMatX = getBoneMatrix(skinIndex.x);\n                            mat4 boneMatY = getBoneMatrix(skinIndex.y);\n                            mat4 boneMatZ = getBoneMatrix(skinIndex.z);\n                            mat4 boneMatW = getBoneMatrix(skinIndex.w);\n                            // update normal\n                            mat4 skinMatrix = mat4(0.0);\n                            skinMatrix += skinWeight.x * boneMatX;\n                            skinMatrix += skinWeight.y * boneMatY;\n                            skinMatrix += skinWeight.z * boneMatZ;\n                            skinMatrix += skinWeight.w * boneMatW;\n                            nml = vec4(skinMatrix * vec4(nml, 0.0)).xyz;\n                            // Update position\n                            vec4 transformed = vec4(0.0);\n                            transformed += boneMatX * pos * skinWeight.x;\n                            transformed += boneMatY * pos * skinWeight.y;\n                            transformed += boneMatZ * pos * skinWeight.z;\n                            transformed += boneMatW * pos * skinWeight.w;\n                            pos = transformed;\n                        }\n                    #endif\n                    void main() {\n                        vec4 pos = vec4(position, 1);\n\n                        vec3 nml = normal;\n                        #ifdef SKINNING\n                            skin(pos, nml);\n                            pos.xyz = rotateToTarget(_Forward, pos.xyz);\n                            nml.xyz = rotateToTarget(_Forward, nml.xyz);\n                        #endif\n                        #ifdef INSTANCED\n                            pos = instanceMatrix * pos;\n                            mat3 m = mat3(instanceMatrix);\n                            nml /= vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2]));\n                            nml = m * nml;\n                        #endif\n                        vUv = uv;\n                        vNormal = normalize(normalMatrix * nml);\n                        pos.xyz += _WorldPosOffset;\n                        vec4 mPos = modelMatrix * pos;\n                        vMPos = mPos.xyz / mPos.w;\n                        vMVPos = modelViewMatrix * pos;\n                        gl_Position = projectionMatrix * vMVPos;\n                    }\n                    ",a=t+"precision highp float;\r\n\r\nvarying vec3 vNormal;\r\n\r\n#define LIGHTPOS vec3(1.0, 1.0, 1.0)\r\n\r\nvoid main() {\r\n\r\n    vec3 col = vec3(1.0);\r\n\r\n    float halfLambert = dot((vNormal), normalize(LIGHTPOS)) * 0.5 + 0.5;\r\n\r\n\r\n    gl_FragColor = vec4(vec3(halfLambert), 1.0);\r\n\r\n}";const r={_Forward:{value:new i(0,0,1)},_WorldPosOffset:{value:new i(0,0,0)}};return new s(this.gl,{uniforms:r,vertex:n,fragment:a,cullFace:null})}wander({time:e}){Math.floor(.001*e)%this.directionStep==0?!1===this.updateDirection&&(console.log("UPDATE DIRECTION"),this.updateDirection=!0,this.randomAngle=Math.random()*this.PI2):this.updateDirection=!1,this.directionOffset.set(Math.cos(this.randomAngle)*this.directionOffsetRadius,0,Math.sin(this.randomAngle)*this.directionOffsetRadius);const t=(new i).copy(this.currentPos).sub(this.prevPos).normalize().scale(4).add(this.directionOffset),n=(new i).copy(this.currentPos).add(t).sub(this.currentPos);n.scale(.015),this.prevPos.copy(this.currentPos),this.currentPos.add(n),this.Mesh.program.uniforms._Forward.value.copy(this.currentPos).sub(this.prevPos).normalize(),this.Mesh.program.uniforms._WorldPosOffset.value.copy(this.currentPos)}animate(){if(this.gltf&&this.gltf.animations&&this.gltf.animations.length){let{animation:e}=this.gltf.animations[0];e.elapsed+=.01,e.update()}}update({time:e,deltaTime:t}){this.wander({time:e}),this.animate()}get Mesh(){return this.mesh}}class z{constructor({el:e}){t(this,"loadModel",(async()=>{this.gltf=await l.load(this.gl,"src/lib/sketches/wandering/assets/kodamav2_no_material_small.gltf"),this.kodamaMesh=new N(this.gl,{gltf:this.gltf}),this.kodamaMesh.setParent(this.scene),this.kodamaMesh.position.y-=1})),this.init({el:e})}init({el:e}){this.renderer=new a({canvas:e,width:e.clientWidth,height:e.clientHeight,antialias:!0,dpr:1}),this.gl=this.renderer.gl;const t=.93;this.gl.clearColor(t,t,t,1);const{clientWidth:s,clientHeight:l}=this.gl.canvas;this.wk=1/s,this.hK=1/l,this.camera=new r(this.gl,{aspect:s/l}),this.camera.position.x=0,this.camera.position.y=10,this.camera.position.z=10,this.controls=new o(this.camera,{target:new i(0,0,0)}),this.scene=new n,this.gltf;const c=new Image;c.crossOrigin="*",c.src="src/lib/sketches/wandering/assets/metallicvoxels.png",this.loadModel()}render({scene:e,camera:t=null,target:n=null,clear:i}){this.renderer.render({scene:e,camera:t,clear:i})}update({time:e,deltaTime:t}){this.controls.update(),this.kodamaMesh&&this.kodamaMesh.update({time:e,deltaTime:t}),this.render({scene:this.scene,camera:this.camera,clear:!0})}onResize(e,t){if(e&&t){this.renderer.setSize(e,t);const{clientWidth:n,clientHeight:i}=this.gl.canvas;this.wk=1/n,this.hK=1/i,this.camera.perspective({aspect:n/i})}}}const{window:S}=k;function A(e){let t,n,i,s,a;return{c(){t=m("main"),n=m("canvas"),this.h()},l(e){t=f(e,"MAIN",{class:!0});var i=u(t);n=f(i,"CANVAS",{class:!0}),u(n).forEach(v),i.forEach(v),this.h()},h(){g(n,"class","webgl-canvas svelte-q6ubty"),g(t,"class","sketch svelte-q6ubty"),p((()=>e[7].call(t)))},m(r,o){x(r,t,o),M(t,n),e[5](n),e[6](t),i=w(t,e[7].bind(t)),s||(a=b(S,"resize",e[4]),s=!0)},p:y,i:y,o:y,d(n){n&&v(t),e[5](null),e[6](null),i(),s=!1,a()}}}function O(e,t,n){let i,s,a,r=2,o=2,l=0,c=0,h=0;P((async()=>{await T(),a=new z({el:s}),d()}));const d=()=>{window.requestAnimationFrame((()=>d())),l=performance.now(),c=.001*(l-h),h=l,a.update({time:l,deltaTime:c})};return[i,s,r,o,()=>{a.onresize({width:r,height:o})},function(e){I[e?"unshift":"push"]((()=>{s=e,n(1,s)}))},function(e){I[e?"unshift":"push"]((()=>{i=e,n(0,i)}))},function(){r=this.clientWidth,o=this.clientHeight,n(2,r),n(3,o)}]}export default class extends c{constructor(e){super(),h(this,e,O,A,d,{})}}
