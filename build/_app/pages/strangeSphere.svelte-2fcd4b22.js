import{H as n,V as r,M as e,T as a,P as t,R as i,I as s,O as o,J as c,S as l,i as v,s as m,e as h,c as p,a as d,d as f,b as x,K as g,f as y,F as u,L as A,N as w,G as L,A as T,Q as F,U as b,W as P}from"../chunks/vendor-5daa0285.js";class z extends n{constructor(n,{radius:e=.5,widthSegments:a=16,heightSegments:t=Math.ceil(.5*a),phiStart:i=0,phiLength:s=2*Math.PI,thetaStart:o=0,thetaLength:c=Math.PI,attributes:l={}}={}){const v=a,m=t,h=i,p=s,d=o,f=c,x=(v+1)*(m+1),g=v*m*6,y=new Float32Array(3*x),u=new Float32Array(3*x),A=new Float32Array(3*x),w=new Float32Array(3*x),L=new Float32Array(2*x),T=x>65536?new Uint32Array(g):new Uint16Array(g);let F=0,b=0,P=0,z=d+f;const M=[];let S=new r,_=new r,C=new r;const I=.5*Math.PI;for(let r=0;r<=m;r++){let n=[],a=r/m;for(let r=0;r<=v;r++,F++){let t=r/v,i=-e*Math.cos(h+t*p)*Math.sin(d+a*f),s=e*Math.cos(d+a*f),o=e*Math.sin(h+t*p)*Math.sin(d+a*f);y[3*F]=i,y[3*F+1]=s,y[3*F+2]=o,S.set(i,s,o).normalize(),u[3*F]=S.x,u[3*F+1]=S.y,u[3*F+2]=S.z;const c=-Math.cos(h+t*p+I),l=0,m=Math.sin(h+t*p+I);_.set(c,l,m).normalize(),A[3*F]=_.x,A[3*F+1]=_.y,A[3*F+2]=_.z,C.copy(S).cross(_).normalize(),w[3*F]=C.x,w[3*F+1]=C.y,w[3*F+2]=C.z,L[2*F]=t,L[2*F+1]=1-a,n.push(b++)}M.push(n)}for(let r=0;r<m;r++)for(let n=0;n<v;n++){let e=M[r][n+1],a=M[r][n],t=M[r+1][n],i=M[r+1][n+1];(0!==r||d>0)&&(T[3*P]=e,T[3*P+1]=a,T[3*P+2]=i,P++),(r!==m-1||z<Math.PI)&&(T[3*P]=a,T[3*P+1]=t,T[3*P+2]=i,P++)}Object.assign(l,{position:{size:3,data:y},normal:{size:3,data:u},tangent:{size:3,data:A},binormal:{size:3,data:w},uv:{size:2,data:L},index:{data:T}}),super(n,l)}}var M="precision highp float;\r\n\r\nuniform sampler2D _MatCap;\r\n\r\nuniform vec3 cameraPosition;\r\nuniform float _Time;\r\n\r\nvarying vec3 vNormal;\r\nvarying vec3 vTangent;\r\nvarying vec2 vUv;\r\nvarying vec4 vMvPos;\r\nvarying vec3 vPos;\r\nvarying float vTarget;\r\n\r\n#define LIGHT vec3(0.0, 5.0, 5.0)\r\n\r\nvec2 matcap(vec3 eye, vec3 normal) {\r\n    vec3 reflected = reflect(eye, normal);\r\n    float m = 2.8284271247461903 * sqrt(reflected.z + 1.0);\r\n    return reflected.xy / m + 0.5;\r\n}\r\n\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 norm = normalize(vNormal);\r\n    vec3 viewDir = normalize(vMvPos.xyz);\r\n\r\n    vec3 hash1 = hash32(gl_FragCoord.xy+fract(_Time)*1387.0);\r\n    vec3 hash2 = hash32(gl_FragCoord.yx+fract(_Time)*1721.0);\r\n    vec3 dither = ((hash1) + (hash2-1.0)) / 255.0;\r\n\r\n    vec2 matcapCoord = matcap(viewDir, norm);\r\n\r\n    float matcapLight = texture2D(_MatCap, matcapCoord).y;\r\n    // matcapLight = matcapLight*matcapLight*matcapLight*matcapLight*matcapLight;\r\n    matcapLight = matcapLight*matcapLight;\r\n    // matcapLight *= 1.2;\r\n\r\n    float halfLambert = dot(norm, normalize(LIGHT))*0.5+0.5;\r\n    // halfLambert = halfLambert*halfLambert;\r\n\r\n    float fresnel = 1.0-(dot(-viewDir, norm)*0.5+0.5);\r\n    fresnel = fresnel * fresnel*fresnel*fresnel;\r\n    fresnel *= 1.0;\r\n\r\n    float fog = smoothstep(8.0, 4.0, vMvPos.z*vMvPos.z);\r\n    // vec3 col = mix(vec3(0.12342, 0.134, 0.9312), vec3(0.95, 0.134, 0.1312), halfLambert);\r\n    vec3 col = mix(norm * 0.5 + 0.5, vec3(halfLambert), 1.0-fresnel);\r\n    // col *= halfLambert + matcapLight;\r\n    // col += matcapLight*.3;\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n    // gl_FragColor = vec4(vec3(matcapLight*(halfLambert+fresnel)), 1.0);\r\n    // gl_FragColor = vec4(vec3(vTarget), 1.0);\r\n    // gl_FragColor = vec4(vec3(halfLambert), 1.0);\r\n    //gl_FragColor = vec4(vec3(mix(vec3(0.0), col, halfLambert*halfLambert)), 1.0);\r\n\r\n}";class S extends e{constructor(n){super(n),console.log(M),this.gl=n,this.initGeometry(),this.initProgram()}initGeometry(){this.geometry=new z(this.gl,{widthSegments:256,radius:1})}initProgram(){const n=new Image;n.crossOrigin="*",n.src="./src/lib/sketches/StrangeSphere/assets/steel.jpg";const r=new a(this.gl,{generateMipMaps:!0});n.onload=()=>r.image=n;const e={_MatCap:{value:r},_Time:{value:0}};this.program=new t(this.gl,{uniforms:e,vertex:"precision highp float;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec3 tangent;\r\nattribute vec3 binormal;\r\nattribute vec2 uv;\r\n\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat3 normalMatrix;\r\n\r\nuniform float _Time;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying vec3 vTangent;\r\nvarying vec4 vMvPos;\r\nvarying vec2 vMatcap;\r\nvarying vec3 vPos;\r\nvarying vec3 vNoise;\r\nvarying float vTarget;\r\n\r\n// #define EPS 0.0005\r\n// #define EPS 0.0005\r\n#define EPS 0.001\r\n\r\n// #define SPATIALF 18.123523\r\n// #define SPATIALF 11.123523\r\n// #define SPATIALF 34.123523\r\n// #define SPATIALF 1.123523\r\n#define SPATIALF 3.723523\r\n// #define SPATIALF 17.345343\r\n#define TEMPORALF 0.7\r\n#define AMP 0.07\r\n#define OCTAVES 4\r\n// #define FALLOFF .731513\r\n#define FALLOFF 0.824\r\n// #define FALLOFF 0.524\r\n// #define FALLOFF 1.0\r\n\r\n// #define SPATIALF 4.123523\r\n// // #define SPATIALF 17.345343\r\n// #define TEMPORALF 0.4\r\n// #define AMP 1.5\r\n// #define OCTAVES 5\r\n// #define FALLOFF 0.531513\r\n\r\n#define m3 mat3(-0.73736, 0.45628, 0.49808, 0, -0.73736, 0.67549, 0.67549, 0.49808, 0.54371)\r\nvec3 sinNoise33(vec3 st) {\r\n    // st.z *= TEMPORALF;\r\n    vec3 noise = vec3(0.0,0.0,0.0);\r\n    float a = 1.0;\r\n    float f = 1.0;\r\n    for(int i = 0; i < OCTAVES; i++) {\r\n        \r\n        st = m3 * st;\r\n        // noise += sin(st.xyz*f)*a;\r\n        noise += sin(st.zxy*f)*a;\r\n        // noise += sin(st.yzx*f)*a;\r\n        // st += (_Time * TEMPORALF*0.125);\r\n        st += noise;\r\n\r\n        //  a *= FALLOFF;\r\n        //  f /= FALLOFF;\r\n    }\r\n    return noise;\r\n}\r\n\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : stegu\r\n//     Lastmod : 20201014 (stegu)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n//               https://github.com/stegu/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n     return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v)\r\n  { \r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n// First corner\r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n// Other corners\r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n\r\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\r\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\r\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n// Permutations\r\n  i = mod289(i); \r\n  vec4 p = permute( permute( permute( \r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n\r\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n\r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n//Normalise gradients\r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n\r\n// Mix final noise value\r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n  m = m * m;\r\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \r\n                                dot(p2,x2), dot(p3,x3) ) );\r\n  }\r\n\r\n  //test this\r\n  //http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\r\n\r\n  mat2 rotate2D(float a) {\r\n\r\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\r\n\r\n  }\r\n\r\nvoid main() {\r\n\r\n    vec3 pos = position;\r\n    vec3 tan = tangent;\r\n    vec3 norm = normal;\r\n    // vec3 biNormal = normalize(cross(tan, norm));\r\n    vec3 biNormal = binormal;\r\n\r\n    // vec3 target = vec3(0.0, 0.0, 1.0) - pos;\r\n    // float dist = length(target);\r\n    // float phase = 1.0-abs(fract(_Time*.1)*2.0 - dist);\r\n    // phase = cos(phase*4.0);\r\n    // phase = pow(phase, 8.0);\r\n\r\n    vTarget = 0.0;\r\n\r\n    // pos += normal * phase * .1;\r\n    \r\n    vec3 up = pos + (biNormal * EPS);\r\n    vec3 down = pos + (biNormal * -EPS);\r\n    vec3 forward = pos + (tan * EPS);\r\n    vec3 back = pos + (tan * -EPS);\r\n\r\n    // float revealDirection = dot(normalize(vec3(cos(_Time) * sin(_Time * 0.5), sin(_Time * 0.5), sin(_Time) * sin(_Time*0.5))), normal) * 0.5+0.5;\r\n    // revealDirection = revealDirection*revealDirection*revealDirection;\r\n    float amp = mix(0.0, AMP, 1.0);\r\n\r\n    vec3 noise = (sinNoise33((pos*SPATIALF) + (_Time * TEMPORALF))*0.5+0.5) * amp;\r\n    vec3 noiseUp = (sinNoise33(up*SPATIALF+ (_Time * TEMPORALF))*0.5+0.5) * amp;\r\n    vec3 noiseDown = (sinNoise33(down*SPATIALF+ (_Time * TEMPORALF))*0.5+0.5) * amp;\r\n    vec3 noiseforward = (sinNoise33(forward*SPATIALF+(_Time * TEMPORALF))*0.5+0.5) * amp;\r\n    vec3 noiseback = (sinNoise33(back*SPATIALF+(_Time * TEMPORALF))*0.5+0.5) * amp;\r\n\r\n    // pos += noise;\r\n    // up += noiseUp;\r\n    // down += noiseDown;\r\n    // forward += noiseforward;\r\n    // back += noiseback;\r\n\r\n    pos += noise;\r\n    up += noiseUp;\r\n    down += noiseDown;\r\n    forward += noiseforward;\r\n    back += noiseback;\r\n\r\n    // float noise = (snoise((pos*SPATIALF) + (_Time * TEMPORALF))*0.5+0.5) * AMP;\r\n    // float noiseUp = (snoise(up*SPATIALF+ (_Time * TEMPORALF))*0.5+0.5) * AMP;\r\n    // float noiseDown = (snoise(down*SPATIALF+ (_Time * TEMPORALF))*0.5+0.5) * AMP;\r\n    // float noiseforward = (snoise(forward*SPATIALF+(_Time * TEMPORALF))*0.5+0.5) * AMP;\r\n    // float noiseback = (snoise(back*SPATIALF+(_Time * TEMPORALF))*0.5+0.5) * AMP;\r\n\r\n    // pos += (pos) * noise;\r\n    // up += (up) * noiseUp;\r\n    // down += (down) * noiseDown;\r\n    // forward += (forward) * noiseforward;\r\n    // back += (back) * noiseback;\r\n\r\n    // vec3 tangentGrad = normalize((pos-back) + (forward-pos));\r\n    // vec3 biNormalGrad = normalize((pos-down) + (up-pos));\r\n\r\n    vec3 tangentGrad = normalize((forward) - (back));\r\n    vec3 biNormalGrad = normalize((up) - (down));\r\n\r\n    //vec3 noisyNormal = (cross(tangentGrad, biNormalGrad));\r\n    vec3 noisyNormal = normalize(cross(tangentGrad, biNormalGrad));\r\n    // vec3 noisyNormal = (cross(tangentGrad, biNormalGrad));\r\n    \r\n    vNormal = normalMatrix * normalize(noisyNormal);\r\n    vTangent = tangent;\r\n    vUv = uv;\r\n    vMvPos = modelViewMatrix * vec4(pos, 1.0);\r\n    vPos = pos;\r\n    vNoise = vec3(noise);\r\n\r\n    gl_Position = projectionMatrix * vMvPos;\r\n\r\n}",fragment:M,cullFace:null})}update({time:n,deltaTime:r}){this.program.uniforms._Time.value+=r}}class _{constructor({el:n}){this.init({el:n}),this.initMesh()}init({el:n}){this.renderer=new i({canvas:n,width:n.clientWidth,height:n.clientHeight,antialias:!0,dpr:1}),this.gl=this.renderer.gl;const e=.93;this.gl.clearColor(e,e,e,1);const{clientWidth:a,clientHeight:t}=this.gl.canvas;this.wk=1/a,this.hK=1/t,this.camera=new s(this.gl,{aspect:a/t}),this.camera.position.x=0,this.camera.position.y=0,this.camera.position.z=5,this.controls=new o(this.camera,{target:new r(0,0,0)}),this.scene=new c}initMesh(){this.sphereMesh=new S(this.gl),this.sphereMesh.setParent(this.scene)}render({scene:n,camera:r=null,target:e=null,clear:a}){this.renderer.render({scene:n,camera:r,clear:a})}update({time:n,deltaTime:r}){this.controls.update(),this.sphereMesh.update({time:n,deltaTime:r}),this.render({scene:this.scene,camera:this.camera,clear:!0})}onResize(n,r){if(n&&r){this.renderer.setSize(n,r);const{clientWidth:e,clientHeight:a}=this.gl.canvas;this.wk=1/e,this.hK=1/a,this.camera.perspective({aspect:e/a})}}}const{window:C}=F;function I(n){let r,e,a,t,i;return{c(){r=h("main"),e=h("canvas"),this.h()},l(n){r=p(n,"MAIN",{class:!0});var a=d(r);e=p(a,"CANVAS",{class:!0}),d(e).forEach(f),a.forEach(f),this.h()},h(){x(e,"class","webgl-canvas svelte-q6ubty"),x(r,"class","sketch svelte-q6ubty"),g((()=>n[7].call(r)))},m(s,o){y(s,r,o),u(r,e),n[5](e),n[6](r),a=A(r,n[7].bind(r)),t||(i=w(C,"resize",n[4]),t=!0)},p:L,i:L,o:L,d(e){e&&f(r),n[5](null),n[6](null),a(),t=!1,i()}}}function N(n,r,e){let a,t,i,s=2,o=2,c=0,l=0,v=0;T((async()=>{await b(),i=new _({el:t}),m()}));const m=()=>{window.requestAnimationFrame((()=>m())),c=performance.now(),l=.001*(c-v),v=c,i.update({time:c,deltaTime:l})};return[a,t,s,o,()=>{i.onresize({width:s,height:o})},function(n){P[n?"unshift":"push"]((()=>{t=n,e(1,t)}))},function(n){P[n?"unshift":"push"]((()=>{a=n,e(0,a)}))},function(){s=this.clientWidth,o=this.clientHeight,e(2,s),e(3,o)}]}export default class extends l{constructor(n){super(),v(this,n,N,I,m,{})}}
